module Types.Log where

import Control.Concurrent.MVar (MVar, newMVar)
import Control.Monad.IO.Class (MonadIO, liftIO)
import GHC.Utils.Outputable (SDoc)
import Prelude hiding (log)
import Types.Target (TargetSpec (..))

-- | Simple log level that decides whether non-diagnostic messages will be sent to Buck in addition to basic file
-- logging.
data LogLevel =
  LogDebug
  |
  LogInfo
  deriving stock (Eq, Show)

-- | The ID of the current build, usually generated by Buck.
newtype TraceId =
  TraceId { string :: String }
  deriving stock (Eq, Show)

-- | The state of log messages, accumulated during a single request and emitted at the end, both to the Buck client and
-- a log file.
data Log =
  Log {
    diagnostics :: [String],
    other :: [(String, LogLevel)],
    traceId :: Maybe TraceId,
    target :: Maybe TargetSpec
  }
  deriving stock (Eq, Show)

newLog ::
  MonadIO m =>
  Maybe TraceId ->
  m (MVar Log)
newLog traceId =
  liftIO $ newMVar Log {diagnostics = [], other = [], traceId, target = Nothing}

-- | Convenience interface for logging.
data Logger =
  Logger {
    withLog :: forall a . (Log -> IO (Log, a)) -> IO a,
    setTarget :: TargetSpec -> IO (),
    debug :: String -> IO (),
    debugD :: SDoc -> IO ()
  }

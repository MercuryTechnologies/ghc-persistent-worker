module Internal.Log where

import Control.Concurrent.MVar (MVar, modifyMVar, modifyMVar_, newMVar)
import Control.Monad (unless)
import Control.Monad.IO.Class (MonadIO, liftIO)
import Data.ByteString (ByteString)
import Data.Text (pack)
import Data.Text.Encoding (encodeUtf8)
import GHC (Ghc, Severity (SevIgnore), noSrcSpan)
import GHC.Driver.Config.Diagnostic (initDiagOpts)
import GHC.Driver.DynFlags (getDynFlags)
import GHC.Driver.Errors.Types (DriverMessage (..), GhcMessage (GhcDriverMessage))
import GHC.Driver.Monad qualified as GHC (logDiagnostics)
import GHC.Types.Error (
  DiagnosticReason (WarningWithoutFlag),
  MessageClass (..),
  getCaretDiagnostic,
  mkLocMessageWarningGroups,
  mkPlainDiagnostic,
  mkSimpleUnknownDiagnostic,
  noHints,
  singleMessage,
  )
import GHC.Utils.Error (mkPlainMsgEnvelope)
import GHC.Utils.Logger (LogAction, LogFlags (..))
import GHC.Utils.Outputable (
  Outputable,
  SDoc,
  blankLine,
  empty,
  getPprStyle,
  renderWithContext,
  setStyleColoured,
  showPprUnsafe,
  withPprStyle,
  ($$),
  ($+$),
  )
import Prelude hiding (log)
import System.Directory (createDirectoryIfMissing, doesPathExist)
import System.FilePath (addExtension, takeDirectory, (</>))
import System.IO (hPutStrLn, stderr)
import System.IO.Error (tryIOError)
import Types.State (Target (..))

-- | Simple log level that decides whether non-diagnostic messages will be sent to Buck in addition to basic file
-- logging.
data LogLevel =
  LogDebug
  |
  LogInfo
  deriving stock (Eq, Show)

-- | The ID of the current build, usually generated by Buck.
newtype TraceId =
  TraceId { string :: String }
  deriving stock (Eq, Show)

data Log =
  Log {
    diagnostics :: [String],
    other :: [(String, LogLevel)],
    traceId :: Maybe TraceId,
    target :: Maybe Target
  }
  deriving stock (Eq, Show)

newLog ::
  MonadIO m =>
  Maybe TraceId ->
  m (MVar Log)
newLog traceId =
  liftIO $ newMVar Log {diagnostics = [], other = [], traceId, target = Nothing}

-- | After the current request's target has been determined, the log state can be updated to generate more specific log
-- file paths.
setLogTarget :: MVar Log -> Target -> IO ()
setLogTarget logVar target =
  modifyMVar_ logVar \ log -> pure log {target = Just target}

logDiagnostics ::
  MonadIO m =>
  MVar Log ->
  String ->
  m ()
logDiagnostics logVar msg =
  liftIO $ modifyMVar_ logVar \ Log {diagnostics, ..} ->
    pure Log {diagnostics = msg : diagnostics, ..}

logOther ::
  MonadIO m =>
  MVar Log ->
  LogLevel ->
  String ->
  m ()
logOther logVar level msg =
  liftIO $ modifyMVar_ logVar \ Log {other, ..} ->
    pure Log {other = (msg, level) : other, ..}

logDir :: FilePath
logDir =
  "/tmp/ghc-persistent-worker/log"

-- | Write the current session's log to a file in 'logDir', using the provided 'LogName' as relative path.
--
-- This name is usually the name of the module being compiled, or @metadata@.
--
-- If the session fails before the target could be determined, this is 'Nothing', so we choose @unknown@ for the file
-- name.
writeLogFile :: Maybe TraceId -> Maybe Target -> [(String, LogLevel)] -> IO ()
writeLogFile traceId target logLines =
  either warn pure =<< tryIOError do
    createDirectoryIfMissing True (takeDirectory path)
    exists <- doesPathExist path
    unless exists do
      writeFile path ""
    appendFile path (unlines (fst <$> logLines))
  where
    path = targetIdDir </> addExtension logName "log"

    targetIdDir | Just (TraceId wtId) <- traceId = logDir </> wtId
                | otherwise = logDir

    warn err = dbg ("Failed to write log file for " ++ logName ++ ": " ++ show err)

    logName = maybe "global" (.path) target

-- | Write the current session's log to a file, clear the fields in the 'MVar' and return the log lines.
logFlush :: MVar Log -> IO [String]
logFlush var = do
  modifyMVar var \ Log {..} -> do
    let logLines = reverse (other ++ [(msg, LogInfo) | msg <- diagnostics])
    writeLogFile traceId target logLines
    pure (Log {diagnostics = [], other = [], ..}, [msg | (msg, level) <- logLines, LogInfo == level])

logFlushBytes :: MVar Log -> IO ByteString
logFlushBytes var = do
  lns <- logFlush var
  pure (encodeUtf8 (pack (unlines lns)))

logToState :: MVar Log -> LogAction
logToState logVar logflags msg_class srcSpan msg = case msg_class of
  MCOutput -> other msg
  MCDump -> other (msg $$ blankLine)
  MCInteractive -> other msg
  MCInfo -> diagnostic msg
  MCFatal -> diagnostic msg
  MCDiagnostic SevIgnore _ _ -> pure ()
  MCDiagnostic _sev _rea _code -> printDiagnostics
  where
    message = mkLocMessageWarningGroups (log_show_warn_groups logflags) msg_class srcSpan msg

    printDiagnostics = do
      caretDiagnostic <-
        if log_show_caret logflags
        then getCaretDiagnostic msg_class srcSpan
        else pure empty
      diagnostic $ getPprStyle $ \style ->
        withPprStyle (setStyleColoured True style) (message $+$ caretDiagnostic $+$ blankLine)

    diagnostic = logDiagnostics logVar . render

    other = logOther logVar LogInfo . render

    render d = renderWithContext (log_default_user_context logflags) d

dbg :: MonadIO m => String -> m ()
dbg = liftIO . hPutStrLn stderr

dbgs :: Show a => MonadIO m => a -> m ()
dbgs = dbg . show

dbgp :: Outputable a => MonadIO m => a -> m ()
dbgp = dbg . showPprUnsafe

logp ::
  Outputable a =>
  MonadIO m =>
  MVar Log ->
  a ->
  m ()
logp logVar =
  logOther logVar LogInfo . showPprUnsafe

logd ::
  MonadIO m =>
  MVar Log ->
  SDoc ->
  m ()
logd = logp


ghcLogd :: SDoc -> Ghc ()
ghcLogd doc = do
  dflags <- getDynFlags
  let diagOpts = initDiagOpts dflags
      reason = WarningWithoutFlag
      msg =
        DriverUnknownMessage $
          mkSimpleUnknownDiagnostic $
          mkPlainDiagnostic reason noHints $
          doc
      msgs = singleMessage (mkPlainMsgEnvelope diagOpts noSrcSpan msg)
  GHC.logDiagnostics (GhcDriverMessage <$> msgs)
